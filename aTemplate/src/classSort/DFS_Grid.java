package classSort;

/**
 * 岛屿数量相关题型
 * 相当于图（网格）的深度优先遍历
 */

/**
 * 求岛屿面积：每遍历到一个格子，就把面积加一。
 * 填海造陆：不能在方格中标记岛屿的面积，而应该标记岛屿的索引（下标），另外用一个数组记录每个岛屿的面积
 *          对网格做了两遍 DFS：第一遍 DFS 遍历陆地格子，计算每个岛屿的面积并标记岛屿；第二遍 DFS 遍历海洋格子，观察每个海洋格子相邻的陆地格子。
 *
 *
*/
public class DFS_Grid {
    public static void main(String[] args) {
        
    }
}


/**
 * 对于网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：
 * <p>
 * 首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。
 * 对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），
 * 四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。
 * 换句话说，网格结构是「四叉」的。
 * <p>
 * 其次，网格 DFS 中的 base case 是什么？
 * 从二叉树的 base case 对应过来，应该是
 * 网格中不需要继续遍历、grid[r][c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子
 */

/**
 * 如何避免重复遍历
 * 网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。
 * 这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。
 * 在图中遍历时，自然可能遇到重复遍历结点。这时候，DFS 可能会不停地「兜圈子」，永远停不下来.
 *
 * 如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。
 * 以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，
 * 这样当我们遇到 2 的时候，就知道这是遍历过的格子了。
 * 也就是说，每个格子可能取三个值：0海洋 1陆地未遍历 2陆地已遍历
 *
 */
class templete_Grid_DFS{
    /**
     * 网格的深度优先遍历
     *
     * @param grid
     * @param r
     * @param c
     */
    void dfs(int[][] grid, int r, int c) {
        // 判断 base case
        // 如果坐标 (r, c) 超出了网格范围，直接返回
        if (!inArea(grid, r, c)) {
            return;
        }

        //如果这个格子不是岛屿直接返回
        if (grid[r][c] != 1) {
            return;
        }
        //去重
        grid[r][c] = 2; // 将格子标记为「已遍历过」

        // 访问上、下、左、右四个相邻结点
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    // 判断坐标 (r, c) 是否在网格中
    boolean inArea(int[][] grid, int r, int c) {
        return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
    }
}